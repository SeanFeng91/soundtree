<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>可调频率共振球体 (Three.js) - AI低语</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #111827; /* Tailwind gray-900 */ color: #f3f4f6; /* Tailwind gray-100 */ }
        #controls { position: absolute; top: 10px; left: 10px; background-color: rgba(17, 24, 39, 0.9); padding: 15px; border-radius: 8px; color: white; font-size: 12px; max-width: 300px; max-height: calc(100vh - 20px); overflow-y: auto; }
        #controls label { display: block; margin-top: 8px; margin-bottom: 3px; font-weight: 500; }
        #controls input[type="range"], #controls select { width: calc(100% - 10px); padding: 4px; border: 1px solid #4b5563; border-radius: 4px; background-color: #374151; color: white; margin-bottom: 3px; font-size: 12px; }
        #controls .value-display { font-weight: normal; color: #9ca3af; margin-left: 5px; }
        #controls button { width: 100%; padding: 8px; background-color: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; font-weight: 500; transition: background-color 0.2s; }
        #controls button:hover { background-color: #2563eb; }
        #controls button:disabled { background-color: #4b5563; cursor: not-allowed; }
        #plotCanvas { display: block; }
        #whisperOutput { margin-top: 15px; padding: 12px; background-color: #374151; border-radius: 4px; min-height: 60px; color: #e5e7eb; font-size: 13px; line-height: 1.6; }
        .loading-dots span { animation: blink 1.4s infinite both; display: inline-block; }
        .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .loading-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink { 0%, 80%, 100% { opacity: 0; } 40% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="controls">
        <div>
            <label for="excitationFrequency">激励频率 (ω, rad/s): <span id="excitationFrequencyValue" class="value-display">200</span></label>
            <input type="range" id="excitationFrequency" min="100" max="12000" step="50" value="200">
        </div>
         <div>
            <label for="mode">共振模态 (参考): <span id="modeValue" class="value-display">1</span></label>
            <select id="mode">
                <option value="1">1阶</option>
                <option value="2">2阶</option>
                <option value="3">3阶</option>
                <option value="4">4阶</option>
            </select>
        </div>
        <button id="playPauseButton">暂停动画</button>
        <div>
            <label for="timeScale">动画速度: <span id="timeScaleValue" class="value-display">1.0</span></label>
            <input type="range" id="timeScale" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>
        <button id="getRodWhisperButton" disabled>✨ 聆听杆件的低语</button>
        <div id="whisperOutput">等待低语...</div>
        <p style="margin-top:10px; font-size:11px; color:#9ca3af;">球直径: 50mm, 杆长: 30-200mm, 杆直径: 2mm. 材质: 钢.</p>
    </div>
    <canvas id="plotCanvas"></canvas>

    <script>
        // --- Three.js 基本设置 ---
        let scene, camera, renderer, sphereMesh;
        const rods = []; 
        let isAnimating = true;
        const clock = new THREE.Clock();
        let animationTime = 0;

        // --- 物理常数 (钢) ---
        const E_modulus = 200e9;  // 杨氏模量 (Pa)
        const density_rho = 7850; // 密度 (kg/m^3)
        const lambda_n_values = [1.875, 4.694, 7.855, 10.996];

        // --- 几何参数 (单位: 米) ---
        const sphereDiameter_m = 0.050; 
        const sphereRadius_m = sphereDiameter_m / 2;
        const minRodLength_m = 0.030; 
        const maxRodLength_m = 0.200; 
        const rodDiameter_m = 0.001;  
        const rodRadius_m = rodDiameter_m / 2;

        const numRods = 150; 
        const maxWobbleAngle = 0.15; 
        const goldenAngle = Math.PI * (3 - Math.sqrt(5)); 

        // --- DOM Elements ---
        const uiElements = {};
        ['excitationFrequency', 'mode', 'timeScale'].forEach(id => {
            uiElements[id] = document.getElementById(id);
            uiElements[`${id}Value`] = document.getElementById(`${id}Value`);
        });
        const playPauseButton = document.getElementById('playPauseButton');
        const getRodWhisperButton = document.getElementById('getRodWhisperButton');
        const whisperOutputDiv = document.getElementById('whisperOutput');
        const canvas = document.getElementById('plotCanvas');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.001, 100);
            camera.position.set(0, sphereRadius_m * 2, sphereRadius_m * 8);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const ambientLight = new THREE.AmbientLight(0x707070);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -0.5, -1);
            scene.add(directionalLight2);

            createSphereWithRods();
            setupEventListeners();
            updateRodResonance(); 
            animate();
        }

        function createSphereWithRods() {
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius_m, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x2563eb, shininess: 70 });
            sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphereMesh);

            const rodGeometryBase = new THREE.CylinderGeometry(rodRadius_m, rodRadius_m, 1, 8); 
            rodGeometryBase.translate(0, 0.5, 0); 

            const defaultLocalRodUp = new THREE.Vector3(0, 1, 0);

            for (let i = 0; i < numRods; i++) {
                const rodLength = THREE.MathUtils.lerp(minRodLength_m, maxRodLength_m, Math.random());
                const grayTone = 0.5 + Math.random() * 0.3; 
                const rodMaterial = new THREE.MeshPhongMaterial({ color: new THREE.Color(grayTone, grayTone, grayTone), shininess: 50 });

                const pivot = new THREE.Group();
                const radialDirection = new THREE.Vector3();

                const y_coord = 1 - (2 * (i + 0.5)) / numRods; 
                const radius_at_y = Math.sqrt(Math.max(0, 1 - y_coord * y_coord));
                const theta_angle = goldenAngle * i; 

                radialDirection.set(
                    Math.cos(theta_angle) * radius_at_y,
                    y_coord,
                    Math.sin(theta_angle) * radius_at_y
                ).normalize();

                pivot.position.copy(radialDirection).multiplyScalar(sphereRadius_m);
                pivot.quaternion.setFromUnitVectors(defaultLocalRodUp, radialDirection);
                
                const rodMesh = new THREE.Mesh(rodGeometryBase.clone(), rodMaterial.clone()); 
                rodMesh.scale.y = rodLength; 

                pivot.add(rodMesh); 
                scene.add(pivot);   

                rods.push({
                    pivot: pivot, 
                    mesh: rodMesh,  
                    length: rodLength,
                    originalColor: rodMaterial.color.clone(),
                    isVibrating: false,
                    vibrationPhase: Math.random() * Math.PI * 2 
                });
            }
        }
        
        function calculateNaturalFrequency(L, r, modeIndex) { 
            const A_area = Math.PI * r * r;
            const I_inertia = (Math.PI * Math.pow(r, 4)) / 4;
            if (L <= 0 || A_area <= 0 || I_inertia <= 0) return Infinity;

            const lambda_n = lambda_n_values[modeIndex - 1];
            if (!lambda_n) return Infinity; 

            const beta = lambda_n / L;
            const omega_n_sqrt_term = (E_modulus * I_inertia) / (density_rho * A_area);
            if (omega_n_sqrt_term < 0) return Infinity;
            
            return Math.pow(beta, 2) * Math.sqrt(omega_n_sqrt_term);
        }

        function updateRodResonance() {
            const excitationFreq = parseFloat(uiElements.excitationFrequency.value);
            const selectedModeIndex = parseInt(uiElements.mode.value); 
            let anyRodVibrating = false;

            rods.forEach(rod => {
                const rodNaturalFreq = calculateNaturalFrequency(rod.length, rodRadius_m, selectedModeIndex);
                const tolerance = rodNaturalFreq * 0.10; 

                if (Math.abs(rodNaturalFreq - excitationFreq) < tolerance) {
                    rod.mesh.material.color.set(0xffd700); 
                    rod.isVibrating = true;
                    anyRodVibrating = true;
                } else {
                    rod.mesh.material.color.copy(rod.originalColor);
                    rod.isVibrating = false;
                }
            });
            getRodWhisperButton.disabled = !anyRodVibrating; // Enable/disable button
        }
        
        function animateRods() {
            const timeScale = parseFloat(uiElements.timeScale.value);
            animationTime += clock.getDelta() * timeScale; 
            const currentExcitationFreq = parseFloat(uiElements.excitationFrequency.value);

            rods.forEach(rod => {
                if (rod.isVibrating) {
                    const wobbleSpeedFactor = currentExcitationFreq / 200; 
                    const wobble = Math.sin(animationTime * wobbleSpeedFactor + rod.vibrationPhase) * maxWobbleAngle;
                    rod.pivot.rotation.x = wobble; 
                } else {
                    rod.pivot.rotation.x = 0;
                    rod.pivot.rotation.z = 0; 
                }
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (isAnimating) {
                animateRods();
            }
            renderer.render(scene, camera);
        }

        async function fetchRodWhisper() {
            const resonatingRods = rods.filter(rod => rod.isVibrating);
            if (resonatingRods.length === 0) {
                whisperOutputDiv.textContent = "此刻万籁俱寂，无杆件低语。";
                return;
            }

            // 选择一个共振杆件 (例如，第一个找到的或最长的)
            const targetRod = resonatingRods.sort((a,b) => b.length - a.length)[0] || resonatingRods[0]; 
            const rodLengthMeters = targetRod.length;
            const currentFreq = parseFloat(uiElements.excitationFrequency.value);

            const originalButtonText = getRodWhisperButton.innerHTML;
            getRodWhisperButton.innerHTML = `正在聆听<span class="loading-dots"><span>.</span><span>.</span><span>.</span></span>`;
            getRodWhisperButton.disabled = true;
            whisperOutputDiv.innerHTML = `正在生成低语... <span class="loading-dots"><span>.</span><span>.</span><span>.</span></span>`;

            const prompt = `一根长度为 ${rodLengthMeters.toFixed(3)} 米的杆件正在以 ${currentFreq.toFixed(0)} rad/s 的频率共振。如果这根杆件能够低语宇宙的奥秘或与其振动相关的古老智慧，它会用一两句富有诗意和想象力的话说些什么？`;
            
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = ""; // API key will be injected by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Gemini API Error:", errorData);
                    whisperOutputDiv.textContent = `抱歉，聆听失败 (HTTP ${response.status})。请稍后再试。`;
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    whisperOutputDiv.textContent = text;
                } else {
                    console.error("Gemini API Error: Unexpected response structure", result);
                    whisperOutputDiv.textContent = "抱歉，未能理解杆件的低语。返回的数据格式似乎有些奇怪。";
                }
            } catch (error) {
                console.error("Error fetching rod whisper:", error);
                whisperOutputDiv.textContent = "抱歉，连接低语时发生网络错误。请检查您的网络连接。";
            } finally {
                getRodWhisperButton.innerHTML = originalButtonText;
                // Re-enable button only if there are still vibrating rods
                updateRodResonance(); // This will re-evaluate and set button disabled state
            }
        }


        function setupEventListeners() {
            Object.keys(uiElements).forEach(key => {
                if (key.endsWith('Value')) return;
                const element = uiElements[key];
                element.addEventListener('input', () => {
                    const value = parseFloat(element.value);
                    let decimals = (key === 'timeScale') ? 1 : 0;
                    uiElements[`${key}Value`].textContent = value.toFixed(decimals);
                    
                    if (key === 'excitationFrequency' || key === 'mode') {
                        updateRodResonance();
                    }
                });
                const initValue = parseFloat(element.value);
                let initDecimals = (key === 'timeScale') ? 1 : 0;
                uiElements[`${key}Value`].textContent = initValue.toFixed(initDecimals);
            });

            playPauseButton.addEventListener('click', () => {
                isAnimating = !isAnimating;
                playPauseButton.textContent = isAnimating ? '暂停动画' : '播放动画';
                if(isAnimating) { 
                    if(!clock.running) clock.start(); // Resume clock if it was explicitly stopped
                } else {
                    // clock.stop(); // Optional: stop clock to truly pause animationTime progression
                }
            });

            getRodWhisperButton.addEventListener('click', fetchRodWhisper);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
